{"meta":{"title":"Aircat's Blog","subtitle":null,"description":null,"author":"aircat","url":"https://zhangzhanbang.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-09-20T11:14:11.964Z","updated":"2018-09-20T11:14:11.964Z","comments":false,"path":"/404.html","permalink":"https://zhangzhanbang.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-09-20T11:11:22.006Z","updated":"2018-09-20T11:11:22.006Z","comments":false,"path":"books/index.html","permalink":"https://zhangzhanbang.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-03-26T14:53:59.833Z","updated":"2019-03-26T14:53:59.833Z","comments":false,"path":"about/index.html","permalink":"https://zhangzhanbang.github.io/about/index.html","excerpt":"","text":"SYSU-ACM’18SYSU-ACM’19"},{"title":"友情链接","date":"2018-09-20T11:11:44.511Z","updated":"2018-09-20T11:11:44.511Z","comments":true,"path":"links/index.html","permalink":"https://zhangzhanbang.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-12-04T04:00:00.000Z","updated":"2018-12-04T04:46:12.385Z","comments":true,"path":"categories/index.html","permalink":"https://zhangzhanbang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-09-20T11:13:46.515Z","updated":"2018-09-20T11:13:46.515Z","comments":false,"path":"repository/index.html","permalink":"https://zhangzhanbang.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-04T04:00:00.000Z","updated":"2018-12-04T04:46:54.390Z","comments":true,"path":"tags/index.html","permalink":"https://zhangzhanbang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2018.12.04","slug":"2018-12-04","date":"2018-12-04T12:29:02.000Z","updated":"2019-03-26T15:29:55.416Z","comments":true,"path":"2018/12/04/2018-12-04/","link":"","permalink":"https://zhangzhanbang.github.io/2018/12/04/2018-12-04/","excerpt":"","text":"nowcoder 296B-Origami题意 有一条有n个格子的纸条，纸条从左到右写着数字1至n。 可进行：左折或右折（以格子间分割线任意折叠） 折到最后，纸条的宽度仅为一个格子，从上往下读取格子的数字得到一个排列。 询问：给出一些排列，问排列能否通过上面的操作得到 分析 不管怎样，当天就是爆零了，可能思路被带偏，不过最终还是自己的问题。 比赛时第一个想法是相邻的数字肯定是连在一起的，然后会有什么方法判断，没多想。 然后有人跟我说，数字大小和位置相邻能不能考虑一下，然后突然觉得很可做，就偏了。 正解跟第一个想法是相关的。 以上都是个人的吐槽。 先模拟一下纸的折叠，会发现若一个方格可分为左右折痕。 假设2k+1与2k+2的折痕为左折痕，那么2k与2k+1为右折痕。 若在相邻数字间按左右折痕，在左右两边连线，那么这些线段在每一边都只能完全覆盖或是相离，若出现相交的情况，则无法通过折叠得出。 因 此，只需判断左右两边线段是否出现了相交的情况即可。（在任意一边，每个点上最多有一条线段） 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define REP(i, a, b) for (int i = (a); i &lt;= (b); ++i)const int N = 1e6+10;int n, a[N], rk[N];int s1[N], s2[N];int main()&#123; int cas; scanf(\"%d\", &amp;cas); while (cas --) &#123; scanf(\"%d\", &amp;n); REP(i, 1, n) scanf(\"%d\", a+i), rk[a[i]] = i; REP(i, 1, n+1) s1[i] = s2[i] = 0; REP(i, 1, n-1) &#123; int l = rk[i], r = rk[i+1]; if (l &gt; r) swap(l, r); if (i&amp;1) s1[l] ++, s1[r+1] --; else s2[l] ++, s2[r+1] --; &#125; REP(i, 2, n+1) s1[i] += s1[i-1], s2[i] += s2[i-1]; bool check = true; REP(i, 1, n-1) &#123; int l = rk[i], r = rk[i+1]; if (l &gt; r) swap(l, r); if ((i&amp;1) &amp;&amp; s1[l] != s1[r]) &#123; check = false; break ; &#125; if (!(i&amp;1) &amp;&amp; s2[l] != s2[r]) &#123; check = false; break ; &#125; &#125; if (check) puts(\"Yes\"); else puts(\"No\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"模型转化","slug":"模型转化","permalink":"https://zhangzhanbang.github.io/tags/模型转化/"}]},{"title":"hello under_world","slug":"hello-underworld","date":"2018-12-03T16:00:00.000Z","updated":"2018-12-04T12:24:01.053Z","comments":true,"path":"2018/12/04/hello-underworld/","link":"","permalink":"https://zhangzhanbang.github.io/2018/12/04/hello-underworld/","excerpt":"","text":"Hello Again Under_World​ 算是第二次建博了，多年后还是选择了NexT（简洁+插件多+优秀）。 ​ 为接下来玩转NexT做好准备！ 建博指南​ 详见大佬Blog ​ 只要认真看完123估计什么都会了","categories":[{"name":"建博","slug":"建博","permalink":"https://zhangzhanbang.github.io/categories/建博/"}],"tags":[]}]}